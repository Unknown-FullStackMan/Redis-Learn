{"diagram":{"image":{"height":200,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","width":200,"y":0,"x":0},"elements":{"id":"root","watermark":"","title":"Redis","leftChildren":[{"id":"5ed2ff74c740","title":"Jedis","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"id":"8d70db59c7ed","title":"redis官方推荐的java连接开发工具。使用java操作redis中间件。如果使用java操作redis，那么一定要对Jedis十分的熟悉","children":[],"parent":"5ed2ff74c740"},{"id":"54b8b6750f3c","title":"导入jedis的包","children":[{"id":"466859cac734","title":"redis.clients/jedis/3.2.0","children":[],"parent":"54b8b6750f3c"}],"parent":"5ed2ff74c740"},{"id":"3bed72baa17b","title":"Jedis jedis = new Jedis(\"127.0.0.1\",6379);","children":[],"parent":"5ed2ff74c740"}],"parent":"root"},{"id":"31f88e5a3852","title":"redis配置文件","lineStyle":{"randomLineColor":"#BE49C4"},"children":[{"id":"7debca75be02","title":"修改daemonize设置位yes，表面是后台运行","children":[{"id":"fae7ec117529","title":"如果以后台运行，需要指定一个pid文件：pidfile /var/run/redis_6379.pid","children":[],"parent":"7debca75be02"}],"parent":"31f88e5a3852"},{"id":"15fae826a67b","title":"把bind 127.0.0.1 这一行注释掉就没有请求服务ip限制了","children":[],"parent":"31f88e5a3852"},{"id":"cf5e14e724e7","title":"把protected-mode 设置成no 即可开启远程访问","children":[],"parent":"31f88e5a3852"},{"id":"58adc045e927","title":"需要永久配置密码的话就去redis.conf的配置文件中找到requirepass这个参数。修改后面的参数并去掉注释即可","children":[{"id":"cd0711654306","title":"或者 使用命令设置密码： config get requirepass 获取redis的密码 然后设置密码：config set requirepass&nbsp; “123456” 登录验证：auth 123456","children":[],"parent":"58adc045e927"}],"parent":"31f88e5a3852"},{"id":"6c3428185bd3","title":"logfile&nbsp; \"\"&nbsp; 日志文件位置名","children":[],"parent":"31f88e5a3852"},{"id":"af3af18e3396","title":"databases 16 默认数据库数量","children":[],"parent":"31f88e5a3852"},{"id":"4b1657f9bf54","title":"always-show-logo yes&nbsp; 总是显示LOGO","children":[],"parent":"31f88e5a3852"},{"id":"0845035ee57a","title":"快照","children":[{"id":"b647302e7913","title":"save 900 1 如果900s内，如果至少有一个key进行了修改，我们就进行持久化操作","children":[],"parent":"0845035ee57a"},{"id":"bee6247dd6dc","title":"stop-writes-on-bgsave-error&nbsp; yes&nbsp; 然后持久化出现问题，还是继续工作","children":[],"parent":"0845035ee57a"},{"id":"290fd6435888","title":"rdbcompression yes 是否压缩rdb文件需要消耗一些cpu资源","children":[],"parent":"0845035ee57a"},{"id":"d58e151ad532","title":"rdbchecksum yes 保存rdb文件进行错误检查校验","children":[],"parent":"0845035ee57a"},{"id":"fcca0327beec","title":"dir ./&nbsp; rdb文件保存的目录","children":[],"parent":"0845035ee57a"}],"parent":"31f88e5a3852"},{"id":"1e7cc0ae1824","title":"限制Clients","children":[{"id":"50eb583b518c","title":"maxclients 1000","children":[],"parent":"1e7cc0ae1824"},{"id":"cef30c00c606","title":"maxmemory redis最大内存容量","children":[],"parent":"1e7cc0ae1824"},{"id":"fb6bf8cd6eb8","title":"maxmemory-policy noeviction 内存达到上限之后的处理策略","children":[{"id":"5b17a01880a3","title":"volatile-lru：只对设置了过期时间的key进行LRU（默认值）","children":[],"parent":"fb6bf8cd6eb8"},{"id":"6293e2c85e9d","title":"allkeys-lru：删除lru算法的key","children":[],"parent":"fb6bf8cd6eb8"},{"id":"20e5cdac2917","title":"volatile-random：随机删除即将过期的key","children":[],"parent":"fb6bf8cd6eb8"},{"id":"f60130ed26bd","title":"allkeys-random：随机删除","children":[],"parent":"fb6bf8cd6eb8"},{"id":"c86bd92d8d9d","title":"volatile-ttl：删除即将过期的","children":[],"parent":"fb6bf8cd6eb8"},{"id":"03a82ba92d70","title":"noeviction：永不过期，返回错误","children":[],"parent":"fb6bf8cd6eb8"}],"parent":"1e7cc0ae1824"}],"parent":"31f88e5a3852"},{"id":"21ff251e9728","title":"APPENDONLY模式( AOF配置)","children":[{"id":"6804c4290a09","title":"appendonly no 默认是不开启aof模式的，默认是使用rdb方式持久化。在大多数情况下，rdb完全够用","children":[],"parent":"21ff251e9728"},{"id":"9ddd2b5de62b","title":"appendfilename&nbsp; ”appendonly.aof“ 持久化文件的名字","children":[],"parent":"21ff251e9728"},{"id":"616b25e2f45e","title":"appendfsync everysec&nbsp; 每秒执行一次sync，可能会丢失这1s的数据","children":[],"parent":"21ff251e9728"},{"id":"da5cba575828","title":"appendfsync no 不执行sync，这个时候操作系统自己同步数据，速度最快","children":[],"parent":"21ff251e9728"}],"parent":"31f88e5a3852"}],"parent":"root"},{"id":"70e2f8ba972b","title":"SpringBoot整合","lineStyle":{"randomLineColor":"#80BA4C"},"children":[{"id":"f4003781dc9e","title":"在springboot2.x之后，原来使用的jedis被替换成lettuce","parent":"70e2f8ba972b","children":[{"id":"bd597d4099c9","title":"jedis：采用直连，多个线程操作不安全。","parent":"f4003781dc9e","children":[]},{"id":"152aba456ab3","title":"lettuce：采用netty，实例可以在多个线程中共享<br>","parent":"f4003781dc9e","children":[]}]},{"id":"8f9f09eba0f0","title":"RedisTemplate","parent":"70e2f8ba972b","children":[{"id":"a19a147becaa","title":"opsForValue","children":[{"id":"8c02a196b132","title":"同样的方法：boundValueOps","children":[],"parent":"a19a147becaa"}],"parent":"8f9f09eba0f0"},{"id":"76d29186475b","title":"opsForList","children":[],"parent":"8f9f09eba0f0"},{"id":"05b9322f6f5d","title":"opsForSet","children":[],"parent":"8f9f09eba0f0"},{"id":"b65d6c64515d","title":"opsForZset","children":[],"parent":"8f9f09eba0f0"},{"id":"4bf0d30b34aa","title":"opsForHash","children":[],"parent":"8f9f09eba0f0"}]},{"id":"10a17231cd35","title":"RedisConnection","children":[{"id":"814db8851ead","title":"获取redis连接对象","children":[],"parent":"10a17231cd35"}],"parent":"70e2f8ba972b"}],"parent":"root"},{"id":"3d1bd196a5da","title":"自定义RedisTemplate","lineStyle":{"randomLineColor":"#3D5EC2"},"parent":"root","children":[{"id":"de9e2160ef3e","title":"<span style=\"color: rgb(77, 77, 77); font-family: -apple-system, &quot;SF UI Text&quot;, Arial, &quot;PingFang SC&quot;, &quot;Hiragino Sans GB&quot;, &quot;Microsoft YaHei&quot;, &quot;WenQuanYi Micro Hei&quot;, sans-serif, SimHei, SimSun; font-size: 16px;\">spring-data-redis的RedisTemplate&lt;K, V&gt;模板类在操作redis时默认使用JdkSerializationRedisSerializer来进行序列化</span>","children":[{"id":"dd3a947fa13b","title":"自定义RestTemplate，使用Jackson2JsonRedisSerializer解决序列化问题，注入的@AutoWired private RedisTemplate redisTemplate;其实是自定义的RestTemplate，","children":[],"parent":"de9e2160ef3e"}],"parent":"3d1bd196a5da"}]},{"id":"ee1c94bb9b3d","title":"Redis持久化","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"id":"dfe8224c8c03","title":"内存数据库，必须把内存中的数据保存到磁盘，一旦服务器进程退出，服务器中的数据库状态也就消失","children":[],"parent":"ee1c94bb9b3d"},{"id":"a2013921d366","title":"RDB（数据快照）dump.rdb","children":[{"id":"80716ee29cb2","title":"在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快<br>照文件直接读到内存里。<br>Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程<br>都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。<br>这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那<br>RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是<br>RDB，一般情况下不需要修改这个配置！<br>有时候在生产环境我们会将这个文件进行备份！<br>rdb保存的文件是dump.rdb 都是在我们的配置文件中快照中进行配置的！<br>触发机制<br>1、save的规则满足的情况下，会自动触发rdb规则<br>2、执行 flushall 命令，也会触发我们的rdb规则！<br>3、退出redis，也会产生 rdb 文件！<br>备份就自动生成一个 dump.rdb都是在我们的配置文件中快照中进行配置的！<br>","children":[],"parent":"a2013921d366"},{"id":"855225488352","title":"dbfilename&nbsp; dump.rdb&nbsp;<br>save 60 5","children":[],"parent":"a2013921d366"},{"id":"f683e83c0eff","title":"触发机制","children":[{"id":"99e43af8b690","title":"1、save的规则满足的情况下，会自动触发rdb规则<br>2、执行 flushall 命令，也会触发我们的rdb规则！<br>3、退出redis，也会产生 rdb 文件！<br>备份就自动生成一个 dump.rdb","children":[],"parent":"f683e83c0eff"}],"parent":"a2013921d366"},{"id":"240c3ec79b41","title":"恢复rdb文件","children":[{"id":"2f20115d84bc","title":"<div><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">1</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">、只需要将</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">rdb</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">文件放在我们</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">redis</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">启动目录就可以，</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">redis</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">启动的时候会自动检查</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">dump.rdb </span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">恢复其中<br></span></div><div><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">的数据！<br></span></div><div><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">2</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">、查看需要存在的位置 config get dir&nbsp;</span></div>","children":[],"parent":"240c3ec79b41"}],"parent":"a2013921d366"},{"id":"286add50e283","title":"优缺点","children":[{"id":"1efefe059f80","title":"优点","children":[{"id":"708d545cf38f","title":"1、适合大规模的数据恢复！ <br>2、对数据的完整性要不高！","children":[],"parent":"1efefe059f80"}],"parent":"286add50e283"},{"id":"3bcdf2a41faa","title":"缺点","children":[{"id":"0666327e968c","title":"1、需要一定的时间间隔进程操作！如果redis意外宕机了，这个最后一次修改数据就没有的了！<br>2、fork进程的时候，会占用一定的内容空间！！<br>3.RDB方式没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能)<br>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(版本不兼容)<br>","children":[],"parent":"3bcdf2a41faa"}],"parent":"286add50e283"}],"parent":"a2013921d366"}],"parent":"ee1c94bb9b3d"},{"id":"a5c611f6b372","title":"AOF（命令快照）appendonly.aof","children":[{"id":"bb3b65c5efd7","title":"将我们的所有命令都记录下来，history，恢复的时候就把这个文件全部在执行一遍！","children":[{"id":"1faff4625f60","title":"以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件\n但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件\n的内容将写指令从前到后执行一次以完成数据的恢复工作","parent":"bb3b65c5efd7","children":[]}],"parent":"a5c611f6b372"},{"id":"b63eadf36c98","title":"修复aof文件","children":[{"id":"4ece23332f7a","title":"工具：redis-check-aof&nbsp; --fix","children":[],"parent":"b63eadf36c98"}],"parent":"a5c611f6b372"},{"id":"ffe1dfdcd3a8","title":"重写规则","children":[{"id":"92ac5b962497","title":"aof默认是文件的无限追加&nbsp; no-appendfsync-on-rewrite no","children":[],"parent":"ffe1dfdcd3a8"},{"id":"a657c90813b8","title":"aotu-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb","children":[{"id":"e6d8498e98bd","title":"如果 aof 文件大于 64m，太大了！ fork一个新的进程来将我们的文件进行重写！","children":[],"parent":"a657c90813b8"}],"parent":"ffe1dfdcd3a8"}],"parent":"a5c611f6b372"},{"id":"4f912d76746c","title":"优缺点","children":[{"id":"77d507637e94","title":"优点","children":[{"id":"60c169c539a3","title":"1、每一次修改都同步，文件的完整会更加好！<br>2、每秒同步一次，可能会丢失一秒的数据<br>3、从不同步，效率最高的！","children":[],"parent":"77d507637e94"}],"parent":"4f912d76746c"},{"id":"c72ba43d6d4a","title":"缺点","children":[{"id":"730c39528d0c","title":"1、相对于数据文件来说，aof远远大于 rdb，修复的速度也比 rdb慢！<br>2、Aof 运行效率也要比 rdb 慢，所以我们redis默认的配置就是rdb持久化！","children":[],"parent":"c72ba43d6d4a"}],"parent":"4f912d76746c"}],"parent":"a5c611f6b372"}],"parent":"ee1c94bb9b3d"},{"id":"73b9ca5b04ad","title":"同时开启两种持久化方式","children":[{"id":"b5b9adb3b85c","title":"1。在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF<br>文件保存的数据集要比RDB文件保存的数据集要完整。<br>2.RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者<br>建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有<br>AOF可能潜在的Bug，留着作为一个万一的手段。","children":[],"parent":"73b9ca5b04ad"}],"parent":"ee1c94bb9b3d"},{"id":"24dc0d5bf812","title":"性能建议","children":[{"id":"d94ae59a4fa0","title":"1.因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够<br>了，只保留 save 900 1 这条规则。<br>2.如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自<br>己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产<br>生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite<br>的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重<br>写可以改到适当的数值。<br>3.如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也<br>减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，<br>启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。","children":[],"parent":"24dc0d5bf812"}],"parent":"ee1c94bb9b3d"}],"parent":"root"},{"id":"60da7715978d","title":"发布/订阅","lineStyle":{"randomLineColor":"#7549C5"},"children":[{"id":"7bd9e62eb03e","title":"subscribe 订阅一个频道","children":[],"parent":"60da7715978d"},{"id":"21a7051c706e","title":"publish 发布者发布消息到频道","children":[],"parent":"60da7715978d"},{"id":"6937e8425fe0","title":"原理","children":[{"id":"0c41865abd77","title":"通过 SUBSCRIBE 命令订阅某频道后，redis-server 里维护了一个字典，字典的键就是一个个 频道！，<br>而字典的值则是一个链表，链表中保存了所有订阅这个 channel 的客户端。SUBSCRIBE 命令的关键，<br>就是将客户端添加到给定 channel 的订阅链表中。","children":[],"parent":"6937e8425fe0"},{"id":"bf7404114b94","title":"通过 PUBLISH 命令向订阅者发送消息，redis-server 会使用给定的频道作为键，在它所维护的 channel<br>字典中查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。","children":[],"parent":"6937e8425fe0"}],"parent":"60da7715978d"}],"parent":"root"},{"id":"ad3d7b963b90","title":"主从复制","lineStyle":{"randomLineColor":"#DD489D"},"children":[{"id":"28b04b33b4a9","title":"概念","children":[{"id":"bec06f7f9211","title":"主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点<br>(master/leader)，后者称为从节点(slave/follower)；数据的复制是单向的，只能由主节点到从节点。<br>Master以写为主，Slave 以读为主。","children":[],"parent":"28b04b33b4a9"}],"parent":"ad3d7b963b90"},{"id":"72ed74e541c4","title":"作用","children":[{"id":"384384594623","title":"1、数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。","children":[],"parent":"72ed74e541c4"},{"id":"0a792b27adc3","title":"2、故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务<br>的冗余。","children":[],"parent":"72ed74e541c4"},{"id":"d6603894b8a7","title":"3、负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务<br>（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写<br>少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。","children":[],"parent":"72ed74e541c4"},{"id":"5eb220edfafa","title":"4、高可用（集群）：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复<br>制是Redis高可用的基础。","children":[],"parent":"72ed74e541c4"}],"parent":"ad3d7b963b90"},{"id":"a00c8cd4fe8c","title":"环境配置","children":[{"id":"bd46a941d973","title":"info replication 查看当前数据库信息","children":[],"parent":"a00c8cd4fe8c"},{"id":"8f3eba0ade6a","title":"步骤：","children":[{"id":"798f495ab237","title":"复制3个配置文件，然后修改对应的信息","children":[{"id":"113e84f61ab4","title":"1、端口<br>2、pid 名字<br>3、log文件名字<br>4、dump.rdb 名字","children":[],"parent":"798f495ab237"}],"parent":"8f3eba0ade6a"},{"id":"9bfb916229a6","title":"从节点连接到主节点","children":[{"id":"1b76274da7d7","title":"在从节点上执行slaveof 127.0.0.1 6379","children":[],"parent":"9bfb916229a6"}],"parent":"8f3eba0ade6a"},{"id":"e7465b2ba0eb","title":"真实的从主配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，暂时的！","children":[],"parent":"8f3eba0ade6a"}],"parent":"a00c8cd4fe8c"}],"parent":"ad3d7b963b90"},{"id":"beaaee1326ce","title":"主机可以写，从机不能写只能读！主机中的所有信息和数据，都会自动被从机保存！<br>","children":[{"id":"26126602e4a7","title":"如果是使用命令行，来配置的主从，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从<br>主机中获取值！","children":[],"parent":"beaaee1326ce"}],"parent":"ad3d7b963b90"},{"id":"440baa93df36","title":"复制原理","children":[{"id":"22430961f0d5","title":"Slave 启动成功连接到 master 后会发送一个sync同步命令<br>Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行<br>完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。<br>全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。<br>增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步<br>但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中<br>看到！","children":[],"parent":"440baa93df36"}],"parent":"ad3d7b963b90"},{"id":"72ed36d92458","title":"手动选举<br>","children":[{"id":"04799ff673df","title":"如果主机断开了连接，我们可以使用 SLAVEOF no one 让自己变成主机！其他的节点就可以手动连\n接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！","parent":"72ed36d92458","children":[]},{"id":"761af93a2cd0","title":"如果主机断开了连接，我们可以使用 SLAVEOF no one 让自己变成主机！其他的节点就可以手动连\n接到最新的这个主节点（手动）！如果这个时候老大修复了，那就重新连接！","parent":"72ed36d92458","children":[]}],"parent":"ad3d7b963b90"},{"id":"eedf98299ba2","title":"哨兵模式（自动选举）","children":[{"id":"376423cd995c","title":"<div><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans;color:rgb(51,51,51);\">Redis</span><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独<br></span></div><div><span style=\"font-size: 9.75453pt; color: rgb(51, 51, 51);\">立运行。其原理是</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:MicrosoftYaHei-Bold;color:rgb(51,51,51);font-weight:bold;\">哨兵通过发送命令，等待</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans-Bold;color:rgb(51,51,51);font-weight:bold;\">Redis</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:MicrosoftYaHei-Bold;color:rgb(51,51,51);font-weight:bold;\">服务器响应，从而监控运行的多个</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:OpenSans-Bold;color:rgb(51,51,51);font-weight:bold;\">Redis</span><span style=\"mso-spacerun:'yes';font-size:9.75453pt;font-family:MicrosoftYaHei-Bold;color:rgb(51,51,51);font-weight:bold;\">实例。&nbsp;</span></div>","children":[],"parent":"eedf98299ba2"},{"id":"4bcde9e442c4","title":"哨兵作用","children":[{"id":"6ef3517f04d8","title":"1通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。<br>2当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服<br>务器，修改配置文件，让它们切换主机。","children":[],"parent":"4bcde9e442c4"}],"parent":"eedf98299ba2"},{"id":"344e6d2b763d","title":"主观下线","children":[{"id":"8d758505d51b","title":"假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主观的认<br>为主服务器不可用，这个现象成为主观下线。","children":[],"parent":"344e6d2b763d"}],"parent":"eedf98299ba2"},{"id":"2343223426dc","title":"客观下线","children":[{"id":"91d798ee3126","title":"当后面的哨兵也检测到主服务器不可用，并且数量达到一<br>定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。<br>切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<br>客观下线。","children":[],"parent":"2343223426dc"}],"parent":"eedf98299ba2"},{"id":"4a923b79eda8","title":"配置哨兵配置文件 sentinel.conf","children":[{"id":"bc55fa5533a5","title":"sentinel monitor myredis 127.0.0.1 6379 1","children":[{"id":"44d968fb60ef","title":"后面的这个数字1，代表主机挂了，slave投票看让谁接替成为主机，票数最多的，就会成为主机！","parent":"bc55fa5533a5","children":[]}],"parent":"4a923b79eda8"}],"parent":"eedf98299ba2"},{"id":"84a722b16104","title":"启动哨兵","children":[{"id":"d6d483f76e33","title":"redis-sentinel&nbsp; &nbsp;sentinel.conf","children":[],"parent":"84a722b16104"}],"parent":"eedf98299ba2"},{"id":"6b1ec2371359","title":"如果Master 节点断开了，这个时候就会从从机中随机选择一个服务器！ （这里面有一个投票算法！）.如果主机此时回来了，只能归并到新的主机下，当做从机，这就是哨兵模式的规则！","children":[],"parent":"eedf98299ba2"},{"id":"da35246df027","title":"优缺点","children":[{"id":"560e85efe58d","title":"优点","children":[{"id":"90152005131b","title":"1、哨兵集群，基于主从复制模式，所有的主从配置优点，它全有<br>2、 主从可以切换，故障可以转移，系统的可用性就会更好<br>3、哨兵模式就是主从模式的升级，手动到自动，更加健壮！","children":[],"parent":"560e85efe58d"}],"parent":"da35246df027"},{"id":"4fe4db1b021b","title":"缺点","children":[{"id":"8dd06591b0fd","title":"1、Redis 不好啊在线扩容的，集群容量一旦到达上限，在线扩容就十分麻烦！<br>2、实现哨兵模式的配置其实是很麻烦的，里面有很多选择！","children":[],"parent":"4fe4db1b021b"}],"parent":"da35246df027"}],"parent":"eedf98299ba2"}],"parent":"ad3d7b963b90"}],"parent":"root"},{"id":"a57113b9ab68","title":"Redis缓存经典问题","lineStyle":{"randomLineColor":"#FD5155"},"children":[{"id":"2d92cdc96616","title":"缓存穿透","children":[{"id":"129d22e63af0","title":"指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，造成缓存穿透。","children":[],"parent":"2d92cdc96616"},{"id":"19bcb43cf04f","title":"解决方案：最简单粗暴的方法如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们就把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br>有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力","children":[],"parent":"2d92cdc96616"}],"parent":"a57113b9ab68"},{"id":"2325dc03ad30","title":"缓存击穿","children":[{"id":"b77c3088c681","title":"当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访<br>问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大","children":[],"parent":"2325dc03ad30"},{"id":"eef3963932e1","title":"解决方案：1.<span style=\"color: rgb(51, 51, 51); font-family: MicrosoftYaHei-Bold; font-size: 9.75453pt; font-weight: bold;\">设置热点数据永不过期<br></span>2.加互斥锁。分布式锁：使用分布式锁，保证对于每个key同时只有一个线程去查询后端服务，其他线程没有获得分布<br>式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考<br>验很大。<span style=\"color: rgb(51, 51, 51); font-family: MicrosoftYaHei-Bold; font-size: 9.75453pt; font-weight: bold;\"><br></span>","children":[],"parent":"2325dc03ad30"}],"parent":"a57113b9ab68"},{"id":"e6079851ae73","title":"缓存雪崩","children":[{"id":"a8c285e49c5b","title":"1.缓存雪崩，是指在某一个时间段，缓存集中过期失效。<br>2.redis宕机。","children":[],"parent":"e6079851ae73"},{"id":"903e376eb5ae","title":"解决方案：<br>1.redis集群2.限流降级3.设置不同的过期时间","children":[],"parent":"e6079851ae73"}],"parent":"a57113b9ab68"},{"id":"c2c0ac23562c","title":"并发竞争问题","children":[{"id":"ef1ed10212bf","title":"利用redis自带的incr命令","children":[],"parent":"c2c0ac23562c"},{"id":"42ca392edcda","title":"可以使用独占锁的方式，类似操作系统的mutex机制。","children":[],"parent":"c2c0ac23562c"},{"id":"8cb70a49156a","title":"使用乐观锁的方式进行解决","children":[],"parent":"c2c0ac23562c"},{"id":"d708c2361133","title":"利用redis的setnx实现内置的锁。","children":[],"parent":"c2c0ac23562c"}],"parent":"a57113b9ab68"}],"parent":"root"},{"id":"d3ccdcae624c","title":"缓存和数据库双写一致性问题","lineStyle":{"randomLineColor":"#0FBAB0"},"children":[{"id":"67a6df350119","title":"先更新数据库 在更新缓存","children":[{"id":"d51d276a49f3","title":"X","children":[],"parent":"67a6df350119"}],"parent":"d3ccdcae624c"},{"id":"cabbcc20a445","title":"先删缓存 再更新数据库","children":[{"id":"32bdf1ca9eaf","title":"采用延时双删策略","children":[],"parent":"cabbcc20a445"}],"parent":"d3ccdcae624c"},{"id":"8d59f53ecca3","title":"先更新数据库 再删缓存","children":[{"id":"3274e15665a1","title":"而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。","children":[],"parent":"8d59f53ecca3"}],"parent":"d3ccdcae624c"}],"parent":"root"}],"structure":"mind_free","root":true,"theme":"delicate_caihong","children":[{"id":"c7a5eff97c01","title":"redis","lineStyle":{"randomLineColor":"#0F80C4"},"parent":"root","children":[{"id":"5feef58292e9","title":"作用","children":[{"id":"5438574a369c","title":"1.内存存储、持久化，内存中是断电即失，所以说持久化很重要（RDB、AOF）","children":[],"parent":"5feef58292e9"},{"id":"95fbb851e8e4","title":"2.效率高，可用于高速缓存","children":[],"parent":"5feef58292e9"},{"id":"e1989c7eb46c","title":"3.发布订阅系统","children":[],"parent":"5feef58292e9"},{"id":"dcb6b447dba6","title":"4.地图信息分析","children":[],"parent":"5feef58292e9"},{"id":"dbb9e6c2ffe8","title":"5.计时器、计数器（浏览量）","parent":"5feef58292e9","children":[]},{"id":"150da1d4eadf","title":"6.。。。。。。","parent":"5feef58292e9","children":[]}],"parent":"c7a5eff97c01"},{"id":"c1870bc029f0","title":"特性","children":[{"id":"a06c88406443","title":"1.多样的数据类型","children":[],"parent":"c1870bc029f0"},{"id":"dfc2744789f6","title":"2.持久化","children":[],"parent":"c1870bc029f0"},{"id":"c24663a15a80","title":"3.集群","children":[],"parent":"c1870bc029f0"},{"id":"3232be80fdf8","title":"4.事务","children":[],"parent":"c1870bc029f0"},{"id":"6c0b7bc59480","title":"5.。。。。","children":[],"parent":"c1870bc029f0"}],"parent":"c7a5eff97c01"}]},{"id":"8303c85e8262","title":"Linux安装","lineStyle":{"randomLineColor":"#7549C5"},"parent":"root","children":[{"id":"ad36702a7458","title":"中文网http://www.redis.cn/","parent":"8303c85e8262","children":[]},{"id":"0458f96b2518","title":"1.下载安装包redis-5.0.8.tar.ga","parent":"8303c85e8262","children":[]},{"id":"47d9c8a3e930","title":"2.解压tar -xzvf","parent":"8303c85e8262","children":[]},{"id":"33678fbc79d8","title":"3.查看redis的配置文件，可修改redis.conf","parent":"8303c85e8262","children":[]},{"id":"14c74fc5814c","title":"4.基础的环境安装。yum install gcc-c++&nbsp; &nbsp; make&nbsp; &nbsp;make install","parent":"8303c85e8262","children":[]},{"id":"dc5f71b64d0d","title":"5.修改redis为后台启动，在redis.conf中把daemonize no改成yes","parent":"8303c85e8262","children":[]},{"id":"871be020738e","title":"6.启动redis。 redis-server&nbsp; redis.conf","parent":"8303c85e8262","children":[]},{"id":"4b457f4ee871","title":"7.使用redis客户端连接测试。redis-cli -p 6379","parent":"8303c85e8262","children":[]},{"id":"7c584c6de3d8","title":"8.关闭redis服务。 shutdown&nbsp; &nbsp; exit","parent":"8303c85e8262","children":[]}]},{"id":"261931b73a64","title":"测试性能工具","lineStyle":{"randomLineColor":"#F88A35"},"children":[{"id":"c046f7089656","title":"redis-benchmark","children":[],"parent":"261931b73a64"}],"parent":"root"},{"id":"6adfaefa43bf","title":"基础知识","lineStyle":{"randomLineColor":"#0FBAB0"},"parent":"root","children":[{"id":"d13b99cd0eea","title":"redis默认是16个数据库 可以使用select number&nbsp; 进行切换数据库","parent":"6adfaefa43bf","children":[]},{"id":"2134f965803d","title":"查看DB大小。DBSIZE","parent":"6adfaefa43bf","children":[]},{"id":"256745e56831","title":"查看数据库的使用key&nbsp;key * ","parent":"6adfaefa43bf","children":[]},{"id":"fe1cc5bf1ec5","title":"清除当前数据库 flushdb","parent":"6adfaefa43bf","children":[]},{"id":"f999b79d0a8f","title":"清楚全部数据库的内容&nbsp; flushall","children":[],"parent":"6adfaefa43bf"},{"id":"591757083716","title":"redis不区分大小写","children":[],"parent":"6adfaefa43bf"},{"id":"b9be3bceaa39","title":"redis为什么是单线程的？","children":[{"id":"dc198cb050dc","title":"Redis是基于内存操作，CPU不是Redis性能瓶颈，redis的瓶颈是根据机器的内存和网络带宽。减少了多线程的上下文切换的性能损耗。Redis是C语言写的，官方提供的数据为100000+的QPS。不比Memecache差","children":[],"parent":"b9be3bceaa39"}],"parent":"6adfaefa43bf"}]},{"id":"f1cf65e5d902","title":"Redis-key命令","lineStyle":{"randomLineColor":"#FCB52A"},"parent":"root","children":[{"id":"e711f0333741","title":"key *&nbsp; 查看所以key","parent":"f1cf65e5d902","children":[]},{"id":"fdf919aee887","title":"exists 查看当前的key是否存在","parent":"f1cf65e5d902","children":[]},{"id":"8b809573fc0b","title":"move&nbsp; 移除当前的key","parent":"f1cf65e5d902","children":[]},{"id":"9fa4d28b0fb2","title":"expire 设置key的过期时间","parent":"f1cf65e5d902","children":[]},{"id":"449f807c58b4","title":"ttl&nbsp; 查看当前key的剩余时间","children":[],"parent":"f1cf65e5d902"},{"id":"5ab413c580e4","title":"type 查看当前key的一个类型","children":[],"parent":"f1cf65e5d902"}]},{"id":"35bb7c70e10c","title":"五大基本数据类型","lineStyle":{"randomLineColor":"#FD5155"},"parent":"root","children":[{"id":"a4a5fcbc8d48","title":"String（字符串）","parent":"35bb7c70e10c","children":[{"id":"6cf9d927712d","title":"set key1 v1","parent":"a4a5fcbc8d48","children":[]},{"id":"2e893b2e0df4","title":"get key1","parent":"a4a5fcbc8d48","children":[]},{"id":"f51f5a81913b","title":"append key1 “hello” 追加字符串，如果当前key不存在，就相当于setkey","parent":"a4a5fcbc8d48","children":[]},{"id":"20122d0e5468","title":"strlen key1 获取字符串的长度","parent":"a4a5fcbc8d48","children":[]},{"id":"3fc5f76c7dba","title":"set view 0， incr views&nbsp; 自增1","parent":"a4a5fcbc8d48","children":[]},{"id":"8014a45be87c","title":"decr views 自减1","parent":"a4a5fcbc8d48","children":[]},{"id":"f8ba9feb22f4","title":"incrby/decrby views 10&nbsp; 设置步长，指定增量","parent":"a4a5fcbc8d48","children":[]},{"id":"d4c51cef220c","title":"getrange key1 0 3&nbsp; 截取字符串【0，3】","children":[],"parent":"a4a5fcbc8d48"},{"id":"d56404d7ea00","title":"getrange key1&nbsp; 0 -1&nbsp; 获取全部的字符串","parent":"a4a5fcbc8d48","children":[]},{"id":"83a1e26d8f3c","title":"setrange key2 1 xx&nbsp; 替换指定位置开始的字符串","parent":"a4a5fcbc8d48","children":[]},{"id":"d864da620138","title":"setex（set with expire） 创建并设置过期时间。setex key3 30&nbsp; “hello”","parent":"a4a5fcbc8d48","children":[]},{"id":"dcc6a935e4f7","title":"setnx（set if not exist） setnx mykey “redis”&nbsp; 如果mykey不存在，就创建mykey。如果存在就创建失败","children":[],"parent":"a4a5fcbc8d48"},{"id":"dd712341dbcb","title":"mset&nbsp; &nbsp;k1 v1&nbsp; k2 v2 k3 v3&nbsp; &nbsp;同时设置多个值","parent":"a4a5fcbc8d48","children":[]},{"id":"242ede92cf78","title":"mget k1 k2 k3&nbsp; 同时获取多个值","children":[],"parent":"a4a5fcbc8d48"},{"id":"f52d8bf147d5","title":"msetnx。同时设置，多个不存在的值。原子操作，要么一起成功，要么一起失败。","parent":"a4a5fcbc8d48","children":[]},{"id":"3de2352fbb03","title":"mset 可以用来创建对象。mset user:1:name zhangsan&nbsp; user:1:age 2","children":[],"parent":"a4a5fcbc8d48"},{"id":"043c6f99ef1f","title":"getset,先get再set。如果存在值，获取原来的值并设置新的值","parent":"a4a5fcbc8d48","children":[]},{"id":"3daa6f026e0c","title":"string的value除了是字符串还可以是数字","children":[],"parent":"a4a5fcbc8d48"},{"id":"c778983fdf57","title":"del 删除键","children":[],"parent":"a4a5fcbc8d48"}]},{"id":"778ae6bc2d44","title":"List（列表）","children":[{"id":"e39f43a0136c","title":"lpush list one&nbsp;lpush list two&nbsp;lpush list three 将一个值或者多个值，插入列表头部（左）","children":[],"parent":"778ae6bc2d44"},{"id":"1e5ee8f277c5","title":"lrange list 0 -1 获取list中的值","children":[],"parent":"778ae6bc2d44"},{"id":"8a6a9667cf07","title":"rpush list righ 将一个值或者多个值插入到列表尾部（右）","children":[],"parent":"778ae6bc2d44"},{"id":"a50a7d1240af","title":"lpop/rpop list 移除list的第一个/最后一个元素","children":[],"parent":"778ae6bc2d44"},{"id":"87ed53905f8a","title":"lindex list 1 通过下标获得list中的某一个值","parent":"778ae6bc2d44","children":[]},{"id":"196bc410283a","title":"llen list 返回列表的长度","children":[],"parent":"778ae6bc2d44"},{"id":"e8882e42bdfe","title":"lrem list 1 one 移除list集合中指定个数的value，精确匹配","children":[],"parent":"778ae6bc2d44"},{"id":"8067b096d519","title":"ltrim mylist 1 2 通过下标截取指定长度，这个list已经改变了，截断了只剩下截取的元素","parent":"778ae6bc2d44","children":[]},{"id":"00154e57f2aa","title":"rpoplpush mylist mylist2&nbsp; 移除列表的最后一个元素，将他移动到新的列表中","children":[],"parent":"778ae6bc2d44"},{"id":"462b2ab3326f","title":"lset list 0 “hello” 选择指定下标元素替换成另一个元素值，如何不存在则报错","children":[],"parent":"778ae6bc2d44"},{"id":"efc70851e1d6","title":"linset 将某个具体的value插入到列 放在你列中某个元素的前面或者后面。linset mylist before “world”“other”","parent":"778ae6bc2d44","children":[]},{"id":"1230bbe5c878","title":"linset mylist after world new","children":[],"parent":"778ae6bc2d44"},{"id":"8e6fb31e4dbb","title":"实际上是个链表，before Node after lef right","children":[],"parent":"778ae6bc2d44"}],"parent":"35bb7c70e10c"},{"id":"be818ecbb5ff","title":"Set（集合无序不重复）","children":[{"id":"c59fb12f3380","title":"sadd&nbsp; myset \"hello\"&nbsp; set集合中添加","children":[],"parent":"be818ecbb5ff"},{"id":"8075bf686d39","title":"smembers myset&nbsp; 查看指定set的所有值","children":[],"parent":"be818ecbb5ff"},{"id":"84308b061d55","title":"sismember myset hello&nbsp; 判断hello值是不是在set集合中","children":[],"parent":"be818ecbb5ff"},{"id":"36e6ec4abe98","title":"scard myset 获取set集合中内容元素的个数","children":[],"parent":"be818ecbb5ff"},{"id":"5207e8f4617d","title":"srem myset hello&nbsp; 移除set集合中的指定元素","children":[],"parent":"be818ecbb5ff"},{"id":"bcddca186487","title":"srandmember myset 【2】 随机抽选一个/多个元素","children":[],"parent":"be818ecbb5ff"},{"id":"1d7447f4e158","title":"spop myset 随机删除一些set集合中的元素","parent":"be818ecbb5ff","children":[]},{"id":"ee9a1aa6d18c","title":"smove myset myset2 “hello” 将一个指定的值，移动到另外一个set集合","parent":"be818ecbb5ff","children":[]},{"id":"2f9648be1778","title":"sdiff 差集，sinter 交集，sunion 并集。","parent":"be818ecbb5ff","children":[]}],"parent":"35bb7c70e10c"},{"id":"7d774367feb7","title":"Hash（哈希）","parent":"35bb7c70e10c","children":[{"id":"461d6fb9956d","title":"Map集合，key-map。","children":[],"parent":"7d774367feb7"},{"id":"24830beec8ea","title":"hset myhash field1&nbsp; simple&nbsp; &nbsp;set一个具体 key-value","children":[{"id":"3402b181b1b4","title":"hget myhash field1 获取一个字段值","parent":"24830beec8ea","children":[]}],"parent":"7d774367feb7"},{"id":"8e5044605180","title":"hmset myhash filed1 hello field2 world set多个key-value","children":[{"id":"353daa276622","title":"hmget myhash field1 field12获取多个字段值","children":[],"parent":"8e5044605180"},{"id":"d66ca87667d5","title":"hgetall myhash 获取全部的数据","children":[],"parent":"8e5044605180"}],"parent":"7d774367feb7"},{"id":"8c0eb160cb52","title":"hdel myhash field1 删除hash指定key字段，对于的value值也就消失了","children":[],"parent":"7d774367feb7"},{"id":"4edd98f5993e","title":"hlen myhash 获取hash表的字段数量","children":[],"parent":"7d774367feb7"},{"id":"1d9a51302436","title":"hexists myhash field1 判断hash中指定字段是否存在","children":[],"parent":"7d774367feb7"},{"id":"3e3b9e9eb755","title":"hkeys myhash 只获取field","children":[],"parent":"7d774367feb7"},{"id":"4b8b717eaca6","title":"hvals myhash 只获取所有value","children":[],"parent":"7d774367feb7"},{"id":"cbaec3a973ce","title":"hincrby没有hdecrby。","children":[],"parent":"7d774367feb7"},{"id":"60ede0d8c40a","title":"hsetnx","parent":"7d774367feb7","children":[]}]},{"id":"4223e51a86f6","title":"Zset（有序集合）","children":[{"id":"89c7431b0bf3","title":"在set的基础上，增加了一个之，set k1 v1 zset k1 score1 v1","children":[],"parent":"4223e51a86f6"},{"id":"b5e8c8e55547","title":"zadd myzset 1 one 添加一个值","children":[],"parent":"4223e51a86f6"},{"id":"643e38f2582d","title":"zadd myzset 2 two 3 three 添加多个值","parent":"4223e51a86f6","children":[]},{"id":"f67ed92cdfff","title":"zrange myzset 0 -1&nbsp; 查看所有值","parent":"4223e51a86f6","children":[]},{"id":"963152055e2b","title":"zrangebyscore myzset -inf +inf 显示全部值&nbsp; 从小到大","children":[],"parent":"4223e51a86f6"},{"id":"95a3e949353a","title":"zrevrange myzset 0 -1 从大到小","children":[],"parent":"4223e51a86f6"},{"id":"d98b8d808ad3","title":"zrangebyscore myzet -inf +inf withscores 显示全部的值并附带成绩","children":[],"parent":"4223e51a86f6"},{"id":"caa1e1d2fa33","title":"zrangebyscore myzet -inf&nbsp; 2500 withscores 显示全部小于2500的值并附带成绩","children":[],"parent":"4223e51a86f6"},{"id":"4f76e86b8d79","title":"zrem mzset one 移除指定元素","children":[],"parent":"4223e51a86f6"},{"id":"0f7e7d295fd7","title":"zcard myzset 获取zset中的个数","children":[],"parent":"4223e51a86f6"},{"id":"a9c17beec963","title":"zcount myzset 1 3 获取指定区间的成员数量","children":[],"parent":"4223e51a86f6"}],"parent":"35bb7c70e10c"}]},{"id":"c596163534df","title":"三种特殊数据类型","lineStyle":{"randomLineColor":"#02ACF4"},"parent":"root","children":[{"id":"09bb33580832","title":"Geospatial地理位置","parent":"c596163534df","children":[{"id":"073f3ef0ebd1","title":"六个命令","parent":"09bb33580832","children":[{"id":"accd69b9779b","title":"geoadd","parent":"073f3ef0ebd1","children":[{"id":"f27d1413efb7","title":"geoadd china:city 116.40&nbsp; 39.90 beijing","parent":"accd69b9779b","children":[]},{"id":"ed32fad2167c","title":"geoadd china:city 121.47 31.23 shanghai","parent":"accd69b9779b","children":[]},{"id":"04466828f929","title":"geoadd china:city 116.40  39.90 beijing&nbsp; china:city 121.47 31.23 shanghai","parent":"accd69b9779b","children":[]}]},{"id":"d7222b72e952","title":"geodist获取两之间的距离","children":[{"id":"120ecc27c60a","title":"geodist china:city beijing shanghai km 直线距离","parent":"d7222b72e952","children":[]}],"parent":"073f3ef0ebd1"},{"id":"d74f3ed7da82","title":"geohash返回一个或者多个位置元素的geohash表示，11个字符的geohash字符串","parent":"073f3ef0ebd1","children":[{"id":"0614f9a5f37a","title":"将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近","parent":"d74f3ed7da82","children":[]},{"id":"b9a19251b4ac","title":"geohash china:city beijing shanghai","parent":"d74f3ed7da82","children":[]}]},{"id":"a50f6b3a4917","title":"geopos获取当前定位的坐标值","children":[{"id":"9ec2bc36fa78","title":"geopos china:city beijing","children":[],"parent":"a50f6b3a4917"}],"parent":"073f3ef0ebd1"},{"id":"06a71b548569","title":"georadius 以给定的经纬度为中心，找出某一半径内的元素","parent":"073f3ef0ebd1","children":[{"id":"dd50f158d467","title":"georadius china:city 110 30 1000 km 以110 30 这个经纬度为中心，寻找方圆1000lm内的城市","children":[],"parent":"06a71b548569"},{"id":"4fcde44fae41","title":"georadius china:city 110 30 500 km withdist 显示到中间距离的位置","parent":"06a71b548569","children":[]},{"id":"0c7b5b19bbf1","title":"georadius china:city 110 30 500 km withcoord 显示他人的定位信息","children":[],"parent":"06a71b548569"},{"id":"247f631e3a07","title":"georadius china:city 110 30 500 km withcoord&nbsp; withdist count 2显示指定个数和信息","parent":"06a71b548569","children":[]}]},{"id":"952c15c38150","title":"georadiusbymember找出位于指定元素周围的其他元素","children":[{"id":"c87184b9c02f","title":"georadiusbymember china:city beijing 1000 km","parent":"952c15c38150","children":[]}],"parent":"073f3ef0ebd1"}]},{"id":"a7444a908ced","title":"底层的实现原理就是zset，可以使用zset命令操作","parent":"09bb33580832","children":[]}]},{"id":"b6d60d06eb93","title":"Hyperloglog","children":[{"id":"f77f40313950","title":"基数统计的算法，容错","children":[],"parent":"b6d60d06eb93"},{"id":"5b091024eff8","title":"占用内存是固定，2的64次方不同的元素技术。只需要占12kb内存。","children":[],"parent":"b6d60d06eb93"},{"id":"52875de53b3f","title":"命令","children":[{"id":"5168004f5e2c","title":"PFadd mykey1 a b c d f g&nbsp;","children":[],"parent":"52875de53b3f"},{"id":"a507fc6a0dcb","title":"PFCOUNT mykey","parent":"52875de53b3f","children":[]},{"id":"4993f388846b","title":"PFadd mykey2 a b c o l k","children":[],"parent":"52875de53b3f"},{"id":"400b01c7c355","title":"PFMERGE mykey3 mykey1 mekey2 合并两组到mykey3","children":[],"parent":"52875de53b3f"}],"parent":"b6d60d06eb93"}],"parent":"c596163534df"},{"id":"c4ec4f53d1db","title":"Bitmap","parent":"c596163534df","children":[{"id":"0228d335b064","title":"位存储，Bitmap位图，数据结构，操作二进制来进行记录。0和1两个状态","parent":"c4ec4f53d1db","children":[]},{"id":"c23dbfb514aa","title":"统计用户信息状态使用bitmaps，例如登录未登录，打卡，未打卡。活跃不活跃","parent":"c4ec4f53d1db","children":[]},{"id":"b1c20c815e97","title":"命令","children":[{"id":"ec75456c02e1","title":"setbin&nbsp; sign 1 0&nbsp;&nbsp;setbin  sign 2 0","children":[],"parent":"b1c20c815e97"},{"id":"3e43fe78e152","title":"bitcount&nbsp; sign&nbsp; 统计只为1的个数","parent":"b1c20c815e97","children":[]}],"parent":"c4ec4f53d1db"}]}]},{"id":"16fcbce301e2","title":"事务","lineStyle":{"randomLineColor":"#0D7C82"},"children":[{"id":"783bd8272e9b","title":"redis的事务没有隔离级别的概念。","parent":"16fcbce301e2","children":[{"id":"8531d4c3ede7","title":"所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会执行。Exec","children":[],"parent":"783bd8272e9b"}]},{"id":"ac52ba710573","title":"redis单条命令保证原子性，但是事务不保证原子性。","parent":"16fcbce301e2","children":[]},{"id":"852b2869ef97","title":"redis事务本质：一组命令的集合，一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行","parent":"16fcbce301e2","children":[{"id":"2fa0aefee6ff","title":"一次性 顺序性 排他性","parent":"852b2869ef97","children":[]}]},{"id":"835dccb49f14","title":"redis事务：","parent":"16fcbce301e2","children":[{"id":"f17cbec3d232","title":"开启事务multi","children":[{"id":"f7ceec4e4c94","title":"取消事务 discard","children":[],"parent":"f17cbec3d232"}],"parent":"835dccb49f14"},{"id":"c84ef18fc6a5","title":"命令入队","children":[{"id":"1a6c9ff148a4","title":"编译型异常代码有问题，命令有错，事务中所有的命令都不会被执行","children":[],"parent":"c84ef18fc6a5"},{"id":"b8f7d5cd22b0","title":"运行时异常，如果事务队列中存在语法错误，那么执行命令的时候其他命令可以正常执行，错误命令抛出异常","children":[],"parent":"c84ef18fc6a5"}],"parent":"835dccb49f14"},{"id":"9ce6d73c7834","title":"执行事务exec","children":[],"parent":"835dccb49f14"}]}],"parent":"root"},{"id":"572785494f27","title":"乐观锁","lineStyle":{"randomLineColor":"#FA5465"},"children":[{"id":"3498cbd5a408","title":"set money 100&nbsp; set out 0","parent":"572785494f27","children":[]},{"id":"bef596608e35","title":"watch money&nbsp; 监视mone对象","children":[{"id":"451b2e334e14","title":"multi&nbsp;","parent":"bef596608e35","children":[{"id":"5f3e46cfd69d","title":"decrby money 20&nbsp; incrby out 20","parent":"451b2e334e14","children":[{"id":"5d00a76745bd","title":"exec","parent":"5f3e46cfd69d","children":[]}]}]}],"parent":"572785494f27"},{"id":"055dbca754a6","title":"如果有多个线程同时操作，那么其中用事务的线程exec执行失败","parent":"572785494f27","children":[]},{"id":"9812c5909d7e","title":"unwatch 如果发现事务执行失败，就先解锁","parent":"572785494f27","children":[{"id":"5c167bbcd05b","title":"然后重新监视","parent":"9812c5909d7e","children":[]}]}],"parent":"root"}],"note":""}},"meta":{"id":"6056dd8663768970076b7f72","member":"6009505ef346fb77714aee48","exportTime":"2021-03-22 14:36:18","diagramInfo":{"category":"mind_free","title":"redis","created":"2021-03-21 13:45:42","creator":"6009505ef346fb77714aee48","modified":"2021-03-22 14:33:25"},"type":"ProcessOn Schema File","version":"1.0"}}